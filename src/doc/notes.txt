try powershell core
	cross platform
	not profiles
	there is a built in one
	there is a portable/sererate one
		powershell 6???

rg
	ripgrep
	pkg install ripgrep
	sample usage
		rg print
		will search all files for print
		highlighted

fd
	search files
	e.g.
		fd py
		lists all .py files

bat
	like cat with syntax highlighting
	very nice output

fzf
	fuzzy finder
	better than find
	pkg install fzf
	sample usage
		vim $(fzf)
		this will help with search/open

wsl as substitute for msys/cygwin
	has package manager
	might run faster
	enable
		gui or cli
			windows features
			windows subsystem for linux
	run
		browser: windows app store ubuntu
		there might also be a powershell script for this
	sudo apt-get update&&sudo apt-get upgrade
	research
		x11 server for wsl

winpython
	portable monolithic

spyder
	ide
	takes long to start
pycharm
	intelij
	might have commercial aspect
most ides use ipython
vscode
	install python extension
	setup posershell for console/setup wsl for console
	has vim extension
ipython
	a more friendly interpreter
jupyter notebook
	interactive
	browser
	charts and data
	you can create notebooks
		these can be used for learning materials as well
vim set color
	:colorscheme industry
python
	module is a dictionary
	dir lists the dictionary
		import math;
		print(dir(math));
investigate cmath
	this is for complex math
	print(3j)
	this also relates to coordinates
		geographical programming
the # comment in python
	helps a lot with # as in bash
python scripts in bash
	#!/bin/bash
	"""
	doc
	string
	"""
	print("asdf")
use of symlinks
	mkdir ~/bin
	ln -s ~/src/python/a.py ~/bin/a
importing
	this actually imports a file
	remember to not name your file
	the same as the thing your are importing
		turtle.py
			import turtle
			#this will reload itself, and not turtle the library
game
	oxygen not inclued
	nor and gates etc
.vimrc
	e ~/.vimrc
	stuff goes there
.vimrc python
	#!/usr/bin/python
	# -*- coding: utf-8 -*-
	# vim: ts=4 sw=4 et:
	the second and third lines
	are not just comments
	research this
	you can set up vimrc to use python documentation 
	research how to accomplish this

pydoc3
	python3 -m pydoc
	or
	pydoc
	this is command line version of
	the help() function from the repl
		e.g.
		for a.py
		pydoc a

single quotes/double quotes
	there is not difference in the interpretation
	e.g. \ in a double or single quote is the same thing

type
	help(type)
	type is also a type
repr
	representation
	print(repr(0)
	print(repr(str(0))
	you can overload repr for a class to provide your own string repr
lists and tuples
	lists and tuples are differentiated on mutability
	main thing to do is iterate over elements of elements
sequence
	the same concept as a colleciton
list
	elements can be of any typea
chr
	there is no chr type, just str
style guid
	dont write wider than 72 characters
list slicing
	[start:end:step]
	end is not included
		[0:4:1]
			0,1,2,3,
	you can also use negative indexes
		[-8:-16:-2]
	there are many experiments you can do with lists and strings to test this
	e.g.
		#reverse
		a="0123456789abcdef";
		print(a[len(a)::-1)
		leaving out second make inclusive
		#reverse alt
		a="0123456789abcdef";
		print(a[::-1)
		leaving out second make inclusive
references
	a=[0]
	b=a
	a.append(1)
	print(b)
research duplication
	through slice
	a=[]
	b=a[:]
	a.push(0)
	print(a)#neq b
	print(b)#neq a
list tuple concatenation
	different types
	so
		list((0,1,2,3))+[]
		tuple([0,1,2,3])+()
take note of the main pattern
	as in a c/cpp prg
pep 8
	style guide for python code
	follow this standard
	there is a tool that can help you
		black
			pip install black
			formatting quality
		or
		flake8
			pip install flake8
			invocation
			python -m flake8 file.py
	and
		pylint
			code quality
			shows if there is not documentation
			you can set up vim to run pylint automatically
	note the output of these programs and learn the style convensions
	style convensions are important in the python world
	global varialbes are supposed to be UPPERCASE
membership
	in is an operator
	a="qwer"
	"q" in a#true
	b=[0,1,2,3]
	0 in b#true
any iterable can be converted to a list or tuple
	list("qwer")
	tuple("qwer")
del
	del is a statement that deletes objects for example from a dictionary
manipulation lists
	a=[0,1,2,3]
	a[:2]=[3,2]
	a=[0,1,2,3]
	a[2:]=[1,0]
	because sliced lhs, its a reference to the subarray
element insertion
	a=list("qwer");
	a[0:0]="X"
	# delete every second
	a=list("0123456789")
	del a[0::2]
	#reverse od
	a=list("01234567890")
	a[::2]=a[::-2]
research
	angled brackets in python documentation referring to class vs referring to object
append
	append pushes an item onto a list
	pop and append goes together
	pop takes away the last element and returns
emptying a list
	clear(somelist)
counting in lists
	print(list("qwer").count("q"))
	print([[1,2],[3,4]].count([1,2]))
take note of all the list operations
	push
	pop
	append
	remove
	index
	...
global reversed()
	returns a copy that is reversed
global sorted()
	returns a copy that is sorted
sort
	a=['4','1','3','2'];
	a.sort()
	print(a)
	a=['4','1','3','2'];
	a.sort(key=len)
	print(a)
	# research: lambdas
	a=['4','1','3','2'];
	a.sort(key=lambda x:len(x))
	print(a)
	a=['4','1','3','2'];
	a.sort(key=lambda x:0-len(x))
	print(a)
catching exceptions
	def is_int(arg,fail=None)
		"""
		"""
		try:
			return int(s)
		except:
			return fail

	print("asdf",0)
string formatting functions
	string -- common string operations
	Lib/string.py
	under built in types
	str.format
		e.g.
			'{:<30}'.format('left aligned')
			read up on how this compares with printf from c
https://incusdata.site/pan/py/python-ipyp-20191007-code.html

pip install local
	pip install --user asdf
	the stuff will be installed to ~/.local/bin
	you have to add this to the path

everything in python is in a dictionary and nested dictionary
	scope and inheritance is implemented with nested dictionaries
	when we talk about a function, it is an entry in an dictionary
	that points to data/code

duck typing
	type is based on qualities of thing???

built in functions
	functions that are built into the language

keywords
	import keyword
	print(keyword.kwlist)
builtins
	import builtins
	print(dir(builtins))
reflection
	die idee dat 'n taal homself kan ontleed

you can actually name things the names of keywords and builtins

repr()
	converts to string
	0.toString()
	repr(0)
numeric to base
	bin(0)
	oct(0)
	hex(0)
pow operator
	**
	e.g.
	2**2
utf-8 is a variable length encoding
	this makes adding numbers to glyphs difficult
	ascii is a subset of utf-8
	so ascii text does not have to be converted to utf-8
how to determine if windows understands utf-8
	"change code page"
	chcp
	how to change it
	chcp 65001
pip multiline
a=(
	"asdf"
	"qwer"
	"zxcv"
)
triple quoted strings
	downside is indentiation, indentation whitespace is included in the value
	the above is an alternative
there is a section in the course notes of dealing with this
also note the escape sequences
formatted strings
	python >=3.6
	a="foo";
	print(f"a: {a}");
	compare that with javascript string literals
	print(f"a:{('_'*8)}")
ord
	ord("asdf")
	ord("a")
	ordinal value of first char
chr
	opposite of ord
	e.g. print(chr(ord("a"))#a
print function
	print("a","b","c")#space seperator
	print("a","b","c",sep="---")#--- seperator
	print("a","b","c",sep="---",end="_")#--- seperator, _ end
	avoid newline at end???
	print("a","b","c",end="")#avoid newline
determine type
	use is operator
	type(0) is int
read up on hackintosh
truthiness
	truth is nebulous
	values are handled as true or false
	e.g.
		if 10:
			print('a');
		if object :
			print('a');
boolean specifics
	user=user or 'anon'
	the truthy value can actually be something else, not necessarily
	a reall boolean
	ensuring functions returned true and executing them from left to right only if all returned true
		f0() and f1() and f2()
if number is too big, its value exceeds 64 bits
	it will be stored in an arbitrary precision type
use double quotes
	because black makes it all double quotes in any ways
read up on string formatting type specifiers
	b	formats an integer as binary
	c	...
	d	...
	e	...
	E	...
	f	...
	F	...
	g	...
	G	...
	n	...
	o	...
	s	...
	x	...
	X	...
vim
	after load before save exec
	black
	:%black something
pandoc 
	can convert md to html etc
	many formats
maketrans and translate
	relates to /bin/tr that translates characters to and from
vim events
	bufleave
	this might be used to run buf on evt
	type :help autocmd
	if you search for BufFilePost/Pre, these are related commands for this
	then a cli proc will exec on these evts
vim multi windows
	ctrl-w n
		new
	ctrl-w w
		switch
you can set up a configure file for pylint
	research this
python vim module
	vim autoformat for python
	you can research modules for vim
dict
	keys can be any immutable type, numeric, string, float, tuple
	you can create a dict with dict()
	you can have strange combintations
	e.g.
	{tuple([]):0}
	{tuple([]):0,tuple([0]):1}
	dictionaries also have operations
dict itr
	for k in myDict:
		print(f"{k},{myDict[k]}");
	for k,v in myDict:
		print(f"{k},{v}");
	see also how to get iterables
lists are faster than dict
you can create an html template with dictionaries
getting values
	{'a':'b'}.get('a')
	{'a':'b'}.get('b')
	{'a':'b'}.get('b','default')
	a['a']
	a['b']
how to get iterables
	a={'a':'a','b':'b'};
	for b in a.items():
		print(b);
how to get the keys
	a={'a':'b','c':'d'};
	for b in a.keys():
		print(a[b])
how to get the values
	a={'a':'b','c':'d'};
	for b in a.values():
		print(b)
you can push and pop on dict
	pop needs a key
setdefault is like get
	but a get if not exists set
	if the key does not exists it operates to create it
	else it works just like get
dict update
	this is like merging dictionaries
print
	there is a way to print to a file
	read up on this
importing
	from flask import Flask
	for example
	lazy (this is frowned upon)
		from flask import *
		there is a way of writing a module that prohibits this
		this has to do with export setup
how to get the modules module from itsef
	__main__ ???
tuples without parentheses
	1,2
	(1,2)
	a,b=1,2
	(a,b)=1,2
	a,b=(1,2)
	(a,b)=(1,2)
swapping
	a,b=1,2
	a,b=b,a
chained assignment
	a=b=c=0
	a,b,c=d,e,f=0,1,2
* in lhs tuple assignment
	a,b,*c=1,2,3,4
	a,*b,c=1,2,3,4
	*a,b,c=d,*e,f=g,h,*i=1,2,3,4
	this is only for python3
	you cannot have to * names in the tpl
try download python for dos
	2.4.2
True and mathematica operators
	True+True # 2
if statements
	if boolean:
		...
	if boolean:
		...
	else:
		...
ternary operator:
	a=0 if boolean else 1;
	this is similar to the conditional operator in c/cpp
  other exc
	  print(0) if true else print(1) if True else print(3)
		compare with
		true?print(0):true?print(1):print(2);

elif
	this is similar to shell scripting
		if a:
			...
		elif b:
			...
		elif c:
			...
if blocks
	you can define a function in a block
		if True:
			def a():
				print('b');
		else:
			def a():
				print('b');
		this might be good for doing version checking os checking
the reason that capital letters have a bigger numerical value is due to the development
at a point there was only capital letters
boolean operators
	and
	or
	not
	...and not && | !
testing in range
	if 1<=n and n<=10:
	special case
		if 1<=n<=10:
			...uniquely pythonic
assertions
	this is about design time
	if there are more asserts then it indicates that it has design
	for example
		import os
		assert(os.path.isfile('/path/to/file'));
	with a message
		import os
		assert(os.path.isfile('/path/to/file')),'msg';
	with a message
	let the program crash with an assert
	you can raise it as follows with a message
		if asdf:
			raise AssertionError('msg');
range based loops:
	instead of using a while loop
		a=0;
		while a<8;
			print(a);
			a=a+1;
	you can use range based loops
		for i in range(8):
			print(i);
		for i in range(0,8):
			print(i);
		for i in range(0,8,1):
			print(i);
		for i in range(8,0,-1):
			print(i);
	range is a class
	it is an iterable
	it is a generator, so it calculates, it does not create the actual
	list, this is lighter on the hardware
	it expects integer values
opamps gates
	read up on that
stl range in cpp
	cpp20 will have range similar to this
enumerate
	this returns a list of tuples with idx and val
	e.g.
	enumerate(['a','b','c'])
	usage
		list(enumerate(['a','b'])) # a tuple (0,'a')
		for a,b in enumerate(l):
			print(a,b)
iterating dictionaries
	d={'a','b'}
	for a in d:
		print(a);
	for a list(d):
		print(a);
	for a d.keys():
		print(a);
items
	{}.items() returns tuples of pairs
zip
	combine lists
		zip([0,1],[2,3])
		list(zip([0,1],[2,3]))
		print(dict(zip(range(0,8,1),range(8,0,-1))))
join
	'seperator'.join(stringOrList)
	','.join('ab')
	','.join(['a','b'])
for and while else clauses
	for and while loops can have else clauses
		if a loop has no break statement, then at the end
		the else will execute or something like that
read up on comprehensions
