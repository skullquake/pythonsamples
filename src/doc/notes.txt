try powershell core
	cross platform
	not profiles
	there is a built in one
	there is a portable/sererate one
		powershell 6???

rg
	ripgrep
	pkg install ripgrep
	sample usage
		rg print
		will search all files for print
		highlighted

fd
	search files
	e.g.
		fd py
		lists all .py files

bat
	like cat with syntax highlighting
	very nice output

fzf
	fuzzy finder
	better than find
	pkg install fzf
	sample usage
		vim $(fzf)
		this will help with search/open

wsl as substitute for msys/cygwin
	has package manager
	might run faster
	enable
		gui or cli
			windows features
			windows subsystem for linux
	run
		browser: windows app store ubuntu
		there might also be a powershell script for this
	sudo apt-get update&&sudo apt-get upgrade
	research
		x11 server for wsl

winpython
	portable monolithic

spyder
	ide
	takes long to start
pycharm
	intelij
	might have commercial aspect
most ides use ipython
vscode
	install python extension
	setup posershell for console/setup wsl for console
	has vim extension
ipython
	a more friendly interpreter
jupyter notebook
	interactive
	browser
	charts and data
	you can create notebooks
		these can be used for learning materials as well
vim set color
	:colorscheme industry
python
	module is a dictionary
	dir lists the dictionary
		import math;
		print(dir(math));
investigate cmath
	this is for complex math
	print(3j)
	this also relates to coordinates
		geographical programming
the # comment in python
	helps a lot with # as in bash
python scripts in bash
	#!/bin/bash
	"""
	doc
	string
	"""
	print("asdf")
use of symlinks
	mkdir ~/bin
	ln -s ~/src/python/a.py ~/bin/a
importing
	this actually imports a file
	remember to not name your file
	the same as the thing your are importing
		turtle.py
			import turtle
			#this will reload itself, and not turtle the library
game
	oxygen not inclued
	nor and gates etc
.vimrc
	e ~/.vimrc
	stuff goes there
.vimrc python
	#!/usr/bin/python
	# -*- coding: utf-8 -*-
	# vim: ts=4 sw=4 et:
	the second and third lines
	are not just comments
	research this
	you can set up vimrc to use python documentation 
	research how to accomplish this

pydoc3
	python3 -m pydoc
	or
	pydoc
	this is command line version of
	the help() function from the repl
		e.g.
		for a.py
		pydoc a

single quotes/double quotes
	there is not difference in the interpretation
	e.g. \ in a double or single quote is the same thing

type
	help(type)
	type is also a type
repr
	representation
	print(repr(0)
	print(repr(str(0))
	you can overload repr for a class to provide your own string repr
lists and tuples
	lists and tuples are differentiated on mutability
	main thing to do is iterate over elements of elements
sequence
	the same concept as a colleciton
list
	elements can be of any typea
chr
	there is no chr type, just str
style guid
	dont write wider than 72 characters
list slicing
	[start:end:step]
	end is not included
		[0:4:1]
			0,1,2,3,
	you can also use negative indexes
		[-8:-16:-2]
	there are many experiments you can do with lists and strings to test this
	e.g.
		#reverse
		a="0123456789abcdef";
		print(a[len(a)::-1)
		leaving out second make inclusive
		#reverse alt
		a="0123456789abcdef";
		print(a[::-1)
		leaving out second make inclusive
references
	a=[0]
	b=a
	a.append(1)
	print(b)
research duplication
	through slice
	a=[]
	b=a[:]
	a.push(0)
	print(a)#neq b
	print(b)#neq a
list tuple concatenation
	different types
	so
		list((0,1,2,3))+[]
		tuple([0,1,2,3])+()
take note of the main pattern
	as in a c/cpp prg
pep 8
	style guide for python code
	follow this standard
	there is a tool that can help you
		black
			pip install black
			formatting quality
		or
		flake8
			pip install flake8
			invocation
			python -m flake8 file.py
	and
		pylint
			code quality
			shows if there is not documentation
			you can set up vim to run pylint automatically
	note the output of these programs and learn the style convensions
	style convensions are important in the python world
	global varialbes are supposed to be UPPERCASE
membership
	in is an operator
	a="qwer"
	"q" in a#true
	b=[0,1,2,3]
	0 in b#true
any iterable can be converted to a list or tuple
	list("qwer")
	tuple("qwer")
del
	del is a statement that deletes objects for example from a dictionary
manipulation lists
	a=[0,1,2,3]
	a[:2]=[3,2]
	a=[0,1,2,3]
	a[2:]=[1,0]
	because sliced lhs, its a reference to the subarray
element insertion
	a=list("qwer");
	a[0:0]="X"
	# delete every second
	a=list("0123456789")
	del a[0::2]
	#reverse od
	a=list("01234567890")
	a[::2]=a[::-2]
research
	angled brackets in python documentation referring to class vs referring to object
append
	append pushes an item onto a list
	pop and append goes together
	pop takes away the last element and returns
emptying a list
	clear(somelist)
counting in lists
	print(list("qwer").count("q"))
	print([[1,2],[3,4]].count([1,2]))
take note of all the list operations
	push
	pop
	append
	remove
	index
	...
global reversed()
	returns a copy that is reversed
global sorted()
	returns a copy that is sorted
sort
	a=['4','1','3','2'];
	a.sort()
	print(a)
	a=['4','1','3','2'];
	a.sort(key=len)
	print(a)
	# research: lambdas
	a=['4','1','3','2'];
	a.sort(key=lambda x:len(x))
	print(a)
	a=['4','1','3','2'];
	a.sort(key=lambda x:0-len(x))
	print(a)
catching exceptions
	def is_int(arg,fail=None)
		"""
		"""
		try:
			return int(s)
		except:
			return fail

	print("asdf",0)
string formatting functions
	string -- common string operations
	Lib/string.py
	under built in types
	str.format
		e.g.
			'{:<30}'.format('left aligned')
			read up on how this compares with printf from c
https://incusdata.site/pan/py/python-ipyp-20191007-code.html

pip install local
	pip install --user asdf
	the stuff will be installed to ~/.local/bin
	you have to add this to the path

everything in python is in a dictionary and nested dictionary
	scope and inheritance is implemented with nested dictionaries
	when we talk about a function, it is an entry in an dictionary
	that points to data/code

duck typing
	type is based on qualities of thing???

built in functions
	functions that are built into the language

keywords
	import keyword
	print(keyword.kwlist)
builtins
	import builtins
	print(dir(builtins))
reflection
	die idee dat 'n taal homself kan ontleed

you can actually name things the names of keywords and builtins

repr()
	converts to string
	0.toString()
	repr(0)
numeric to base
	bin(0)
	oct(0)
	hex(0)
pow operator
	**
	e.g.
	2**2
utf-8 is a variable length encoding
	this makes adding numbers to glyphs difficult
	ascii is a subset of utf-8
	so ascii text does not have to be converted to utf-8
how to determine if windows understands utf-8
	"change code page"
	chcp
	how to change it
	chcp 65001
pip multiline
a=(
	"asdf"
	"qwer"
	"zxcv"
)
triple quoted strings
	downside is indentiation, indentation whitespace is included in the value
	the above is an alternative
there is a section in the course notes of dealing with this
also note the escape sequences
formatted strings
	python >=3.6
	a="foo";
	print(f"a: {a}");
	compare that with javascript string literals
	print(f"a:{('_'*8)}")
ord
	ord("asdf")
	ord("a")
	ordinal value of first char
chr
	opposite of ord
	e.g. print(chr(ord("a"))#a
print function
	print("a","b","c")#space seperator
	print("a","b","c",sep="---")#--- seperator
	print("a","b","c",sep="---",end="_")#--- seperator, _ end
	avoid newline at end???
	print("a","b","c",end="")#avoid newline
determine type
	use is operator
	type(0) is int
read up on hackintosh
truthiness
	truth is nebulous
	values are handled as true or false
	e.g.
		if 10:
			print('a');
		if object :
			print('a');
boolean specifics
	user=user or 'anon'
	the truthy value can actually be something else, not necessarily
	a reall boolean
	ensuring functions returned true and executing them from left to right only if all returned true
		f0() and f1() and f2()
if number is too big, its value exceeds 64 bits
	it will be stored in an arbitrary precision type
use double quotes
	because black makes it all double quotes in any ways
read up on string formatting type specifiers
	b	formats an integer as binary
	c	...
	d	...
	e	...
	E	...
	f	...
	F	...
	g	...
	G	...
	n	...
	o	...
	s	...
	x	...
	X	...
vim
	after load before save exec
	black
	:%black something
pandoc 
	can convert md to html etc
	many formats
maketrans and translate
	relates to /bin/tr that translates characters to and from
vim events
	bufleave
	this might be used to run buf on evt
	type :help autocmd
	if you search for BufFilePost/Pre, these are related commands for this
	then a cli proc will exec on these evts
vim multi windows
	ctrl-w n
		new
	ctrl-w w
		switch
you can set up a configure file for pylint
	research this
python vim module
	vim autoformat for python
	you can research modules for vim
dict
	keys can be any immutable type, numeric, string, float, tuple
	you can create a dict with dict()
	you can have strange combintations
	e.g.
	{tuple([]):0}
	{tuple([]):0,tuple([0]):1}
	dictionaries also have operations
dict itr
	for k in myDict:
		print(f"{k},{myDict[k]}");
	for k,v in myDict:
		print(f"{k},{v}");
	see also how to get iterables
lists are faster than dict
you can create an html template with dictionaries
getting values
	{'a':'b'}.get('a')
	{'a':'b'}.get('b')
	{'a':'b'}.get('b','default')
	a['a']
	a['b']
how to get iterables
	a={'a':'a','b':'b'};
	for b in a.items():
		print(b);
how to get the keys
	a={'a':'b','c':'d'};
	for b in a.keys():
		print(a[b])
how to get the values
	a={'a':'b','c':'d'};
	for b in a.values():
		print(b)
you can push and pop on dict
	pop needs a key
setdefault is like get
	but a get if not exists set
	if the key does not exists it operates to create it
	else it works just like get
dict update
	this is like merging dictionaries
print
	there is a way to print to a file
	read up on this
importing
	from flask import Flask
	for example
	lazy (this is frowned upon)
		from flask import *
		there is a way of writing a module that prohibits this
		this has to do with export setup
how to get the modules module from itsef
	__main__ ???
tuples without parentheses
	1,2
	(1,2)
	a,b=1,2
	(a,b)=1,2
	a,b=(1,2)
	(a,b)=(1,2)
swapping
	a,b=1,2
	a,b=b,a
chained assignment
	a=b=c=0
	a,b,c=d,e,f=0,1,2
* in lhs tuple assignment
	a,b,*c=1,2,3,4
	a,*b,c=1,2,3,4
	*a,b,c=d,*e,f=g,h,*i=1,2,3,4
	this is only for python3
	you cannot have to * names in the tpl
try download python for dos
	2.4.2
True and mathematica operators
	True+True # 2
if statements
	if boolean:
		...
	if boolean:
		...
	else:
		...
ternary operator:
	a=0 if boolean else 1;
	this is similar to the conditional operator in c/cpp
  other exc
	  print(0) if true else print(1) if True else print(3)
		compare with
		true?print(0):true?print(1):print(2);

elif
	this is similar to shell scripting
		if a:
			...
		elif b:
			...
		elif c:
			...
if blocks
	you can define a function in a block
		if True:
			def a():
				print('b');
		else:
			def a():
				print('b');
		this might be good for doing version checking os checking
the reason that capital letters have a bigger numerical value is due to the development
at a point there was only capital letters
boolean operators
	and
	or
	not
	...and not && | !
testing in range
	if 1<=n and n<=10:
	special case
		if 1<=n<=10:
			...uniquely pythonic
assertions
	this is about design time
	if there are more asserts then it indicates that it has design
	for example
		import os
		assert(os.path.isfile('/path/to/file'));
	with a message
		import os
		assert(os.path.isfile('/path/to/file')),'msg';
	with a message
	let the program crash with an assert
	you can raise it as follows with a message
		if asdf:
			raise AssertionError('msg');
range based loops:
	instead of using a while loop
		a=0;
		while a<8;
			print(a);
			a=a+1;
	you can use range based loops
		for i in range(8):
			print(i);
		for i in range(0,8):
			print(i);
		for i in range(0,8,1):
			print(i);
		for i in range(8,0,-1):
			print(i);
	range is a class
	it is an iterable
	it is a generator, so it calculates, it does not create the actual
	list, this is lighter on the hardware
	it expects integer values
opamps gates
	read up on that
stl range in cpp
	cpp20 will have range similar to this
enumerate
	this returns a list of tuples with idx and val
	e.g.
	enumerate(['a','b','c'])
	usage
		list(enumerate(['a','b'])) # a tuple (0,'a')
		for a,b in enumerate(l):
			print(a,b)
iterating dictionaries
	d={'a','b'}
	for a in d:
		print(a);
	for a list(d):
		print(a);
	for a d.keys():
		print(a);
items
	{}.items() returns tuples of pairs
zip
	combine lists
		zip([0,1],[2,3])
		list(zip([0,1],[2,3]))
		print(dict(zip(range(0,8,1),range(8,0,-1))))
join
	'seperator'.join(stringOrList)
	','.join('ab')
	','.join(['a','b'])
for and while else clauses
	for and while loops can have else clauses
		if a loop has no break statement, then at the end
		the else will execute or something like that
read up on comprehensions
how to upgrade pip
				python -m pip install pip --upgrade
				you can manipulate pip config in pip.conf
				you can also have a pip.conf in the venv for the local pip
				to duplicate a venv and ensure it remains the same
								pip freeze > requirements.txt
								create new env
								activate
								copy requirements.txt
								pip install -r requirements.txt
[un]installing with pip and upgrading
				pip install flask
				pip flask --upgrade
				pip uninstall flask
pip list packages
				pip list
								list installed packages
				pip search
virtual environments
				you can use virtualenv which is older
				or you can use venv which is newer
								python -m venv
								this came out around python 3.3
venv
				python -m venv --prompt MYPY mypy
whl
				this is an old thing
other environment tools
				pipenv
				pyenv
								this allows you to install specific versions
								of python
				research this
pypi
				pypi.org
				this is where pip searches for modules
				if something is on pypi its installable and
				has documentation
flatpak
				making things portable
				this is like protable app or osx app folder thingy
				e.g.
								you can install visual studio code as a flatpak
								just as an example
				research this
comprehensions
				its an abstract shorter way to create lists
				its a syntax to create a list
				#create list ints
				[a for a in range(8)]
				#you can use comprehensions in comprehensions
				[b for b in [a for a in range(8)a]]
				#create list of lists
				[[b] for b in [a for a in range(8)a]]
				#create list of tuples
				[(b,) for b in [a for a in range(8)a]]
				print([(b,b**b) for b in [a for a in range(8)a]]);
								equiv
												a=[];
												for b in range(8):
																a.append((b,b**b));
												print(a);
				#figure out what this does
								[[a for c in range(8)] for a in range(8)]
								this seems to create a 2d array
vim
				practice using .
memoization
				cache expensive calculations
comprehensions nested loops
				[(a,b) for a in [0,1] for b in [2,3]]
markdown
				commonmark java impl
				pandoc does that as well
vim modules
				vimbal
								this is old
				pathogen
								a module manager
								unzip
								deploy
								modify .vimrc
				vundel
								this can get stuff from github
tmux customizations and plugins
modifying the statusline in vim
iosefka font
				you can compile and modify this
				this is not build with svg its built using a languagse
generator:
				for b in (a**a for a in range(8)):
								print(b);
				(a**a for a in range(8))
								this is a generator
								it creates elements on the fly
								the difference is () vs [] that encloses it all
exec and eval
				eval executes and returns value
				exec executes and returns nothing
				you can create a scope and give it to eval or exec as its scope
								a={}
								eval('0',a);
								exec('print(0)',a);
								a={'b':'c'};
								exec('print(b);');
callable
				def a():
								return;
				type(a);#function
				callable(a);#function
				if no return is specified it will return none, e.g.
								def a():
												...
				return is actually an unnamed variable
positional parameters
				def a(b,c):
								print(b);
								print(c);
								return;
				#positional call
				a('a','b');
				#kwargs 
				a(a='a',b='b');
				a(b='b',a='a');
one line functions:
				def a(): return;
md
				headings
								#
								##
								###
				italic
								*
				code
								```
								```
				esc *
								\*
main formats
				common mark
				md
				restructured text
				asciidoc
				pandoc
								swis army knife
								programmable
								can convert to x
you can program pandoc with lua
latex pronunctiation
				late[gh]
				other
								contex
								luatex ...
python function scope
				the function upon call has its own dictionary
passing lists or dictionaries as parameter
				pass by reference trick
function pass by reference
				you have to use a hack
				a=[8];
				def b(c):
								c[0]=c[0]++;
				print(a);
				b(a);
				print(a);
				#you can also do it with a dictionary
read up on 
				default values for parameters
				required parameters
collecting parameters
				def a(*b):
								print(b);
								print(type(b));
				b will be a tuple
				you can write flexible functions with this
				if a function in the api is defined as foo(*bar) then it 
				refers to collecting parameters
								print(b);
				a(1,2,3);
collecting parameters and normal params
				def a(b,*c):
								print(b);
								print(c);
				a(1,2,3);#1 will go into b, 2,3 will go into c
collecting arguments
				def a(b,c,d):
								print(a);
								print(b);
								print(c);
								return;
				b={'b':'b','c':'c','d','d'};
				a(**b);
				or
				a({'b':'b','c':'c','d','d'});
** arg
				#kwarg par
				def a(**b):
								print(b);
				a(b=0,c=1,d=2);
				#will print dict
vars
				vars is a global function
				shows variables
				e.g.
				a=0;
				print(vars()['a']);
is this useful
				import module if not already imported
				exec('import random') if not vars().get('random') else None;
scope
				python implements scope with dictionaries
send scope to fn
				def a(b):
								b['a']=1;
								return;
				a=0;
				print(a);
				a(vars());
				print(a);
fn decl glob var
				#talk out
				def a():
								global b;
								b=0;
				type(b);
				a();
				type(b);
				print(b);
shadowing
				local variable supercedes same named variable from higher scope
globals
				globals() function returns dictionary of global variables
				you can manipulate this
				compare with vars()
				run this in a function to see how it behaves
function
				creating a name with a callable value
nesting functions
				def a():
								def b():
												return;
								return;
returning a function
				# this returns a function pointer
				def a():
								def b():
												return;
								return a;
				# call
				a()()
putting functions in dict
				def a():
								def b():
												return;
								def c():
												return;
								return {"b":b,"c":c};
				a()["a"]()
				a()["b"]()
interesting combination
				def a(b):
								def c(d):
												return b+d;
								return c;
				print(a(1)(2))
				# the above indicates that python engine will realize
				# that the returned function references a scope
				# and that the outer scope should not be destroyed
				# this has to do with closure
				# python has to capture the scope
				# read up on this
				# you can use this to store variables, play with vars() and stuff
				def a():
								c=0;
								def b(c=vars()):
												c+=1;
												print(c);
												return;
								return b;
				b=a();
				b();
				b();
				b();
recursion
				def a(b):
								print("{}".format(b));
								a(b-1) if b>0 else None;
				there is nothing special about recursion as you can implement
				it using standard things, setting up a stack manually etc
map
				remaps values
								def a(b):
												return b*b;
								list(map(a,[1,2,3]));
filter
				def a(b):
								return b%2==0;
				list(filter(a,range(8)));
lambdas in python
				are not so useful
				it can only have one statement
				you can hack a multiline with exec("""line...""") though
argument parsing library
				argparse
vim can be extend
				first check if vim is compiled with python
				vim --version
								check for -lpythonxxx linked in
				read up on ftplugin
								$HOME/.vim/ftplugin/python.vim
								and then you can put stuff in your .vimra
				just google how to write a python plugin for vim
				:echo has('python')
				or
				:echo has('python3')
				airline has a predecessor written in python
				many plugins are in python
				you can set up something like make if you run make
				then it runs pylint and things for you
				python might be a function in vim
